\documentclass[12pt]{article}

\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian, english]{babel}
\usepackage{graphicx}
\usepackage{amsthm,amsmath,amssymb}
\usepackage[russian,colorlinks=true,urlcolor=red,linkcolor=blue]{hyperref}
\usepackage{enumerate}
\usepackage{datetime}
\usepackage{minted}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{color}

%\newmintinline[cpp]{cpp}{}

\def\NAME{123}
% \def\DATE{21 ноября}
% \def\CURNO{\NO\t{8}}

\sloppy
\voffset=-20mm
\textheight=235mm
\hoffset=-25mm
\textwidth=180mm
\headsep=12pt
\footskip=20pt

\setcounter{page}{1}
\pagestyle{empty}

\newlength{\tmplen}
\newlength{\tmpwidth}
\newcounter{listcounter}

% Основные математические символы
\newcommand{\N}{\mathbb{N}}   % Natural numbers
\newcommand{\R}{\mathbb{R}}   % Ratio numbers
\newcommand{\Z}{\mathbb{Z}}   % Integer numbers
\def\EPS{\varepsilon}         %
\def\SO{\Rightarrow}          % =>
\def\EQ{\Leftrightarrow}      % <=>
\def\t{\texttt}               %
\def\O{\mathcal{O}}           %
\def\NO{\t{\#}}               % #
\renewcommand{\le}{\leqslant} % <=, beauty
\renewcommand{\ge}{\geqslant} % >=, beauty
\def\XOR{\text{ {\raisebox{-2pt}{\ensuremath{\Hat{}}}} }}
\newcommand{\q}[1]{\langle #1 \rangle}               % <x>
\newcommand\URL[1]{{\footnotesize{\url{#1}}}}        %
\newcommand{\sfrac}[2]{{\scriptstyle\frac{#1}{#2}}}  % Очень маленькая дробь
\newcommand{\mfrac}[2]{{\textstyle\frac{#1}{#2}}}    % Небольшая дробь
\newcommand{\score}[1]{{\bf\color{red}{(#1)}}}
% Отступы
\def\makeparindent{\hspace*{\parindent}}
\def\up{\vspace*{-\baselineskip}}
\def\down{\vspace*{\baselineskip}}
\def\LINE{\vspace*{-1em}\noindent \underline{\hbox to 1\textwidth{{ } \hfil{ } \hfil{ } }}}

\lhead{SPB HSE (Babushkin, Makhnev, Surkov)}
\chead{}
\rhead{Page \thepage\t\ of \pageref*{LastPage}}
\renewcommand{\headrulewidth}{0.4pt}

\lfoot{}
\cfoot{}
\rfoot{}
% \renewcommand{\footrulewidth}{0.4pt}

\newcommand{\BeginConspect}{
  \pagestyle{fancy}
  % \fancyhead[C]{\thepage}
}

\newenvironment{MyList}[1][4pt]{
  \begin{enumerate}[1.]
  \setlength{\parskip}{0pt}
  \setlength{\itemsep}{#1}
}{       
  \end{enumerate}
}
\newenvironment{InnerMyList}[1][0pt]{
  \vspace*{-0.5em}
  \begin{enumerate}[a)]
  \setlength{\parskip}{#1}
  \setlength{\itemsep}{0pt}
}{
  \end{enumerate}
}

\newcommand{\Section}[1]{
  \refstepcounter{section}
  \addcontentsline{toc}{section}{\arabic{section}. #1} 
  %{\LARGE \bf \arabic{section}. #1} 
  {\LARGE \bf #1} 
  \vspace*{1em}
  \makeparindent\unskip
}
\newcommand{\Subsection}[1]{
  \refstepcounter{subsection}
  \addcontentsline{toc}{subsection}{\arabic{section}.\arabic{subsection}. #1} 
  {\Large \bf \arabic{section}.\arabic{subsection}. #1} 
  \vspace*{0.5em}
  \makeparindent\unskip
}

% Код с правильными отступами
\newenvironment{code}{
  \VerbatimEnvironment

  \vspace*{-0.5em}
  \begin{minted}{c}}{
  \end{minted}
  \vspace*{-0.5em}

}

\begin{document}

\renewcommand{\dateseparator}{--}

\BeginConspect

\tableofcontents
\pagebreak

\Section{Suffix Tree}

\begin{minted}[linenos,frame=single]{c++}
// Ukkonen's algorithm O(n)
const int A = 27; // Alphabet size
struct SuffixTree {
    struct Node { // [l, r) !!!
        int l, r, link, par;
        int nxt[A];
        Node(): l(-1), r(-1), link(-1), par(-1) { fill(nxt, nxt + A, -1); }
        Node(int _l, int _r, int _link, int _par): 
        l(_l), r(_r), link(_link), par(_par) { fill(nxt, nxt + A, -1); }
        int &next(int c) { return nxt[c]; }
        int get_len() const { return r - l; }
    };
    struct State { int v, len; };
    vec< Node > t;
    State cur_state;
    vec< int > s;
    SuffixTree(): cur_state({0, 0}) { t.push_back(Node()); }
    // v -> v + s[l, r) !!!
    State go(State st, int l, int r) {
        while(l < r) {
            if(st.len == t[st.v].get_len()) {
                State nx = State({ t[st.v].next(s[l]), 0 });
                if(nx.v == -1) return nx;
                st = nx;
                continue;
            }
            if(s[ t[st.v].l + st.len ] != s[l]) return State({-1, -1});
            if(r - l < t[st.v].get_len() - st.len) 
                return State({st.v, st.len + r - l});
            l += t[st.v].get_len() - st.len;
            st.len = t[st.v].get_len();
        }
        return st;
    }
    int get_vertex(State st) {
        if(t[st.v].get_len() == st.len) return st.v;
        if(st.len == 0) return t[st.v].par;
        Node &v = t[st.v];
        Node &pv = t[v.par];
        Node add(v.l, v.l + st.len, -1, v.par);
        // nxt
        pv.next(s[v.l]) = (int)t.size();
        add.next(s[v.l + st.len]) = st.v;
        // par
        v.par = (int)t.size();
        // [l, r)
        v.l += st.len;
        t.push_back(add); // !!!
        return (int)t.size() - 1;
    }
    int get_link(int v) {
        if(t[v].link != -1) return t[v].link;
        if(t[v].par == -1) return 0;
        int to = get_link(t[v].par);
        to = get_vertex(
            go(State({to, t[to].get_len()}), t[v].l + (t[v].par == 0), t[v].r)
        );
        return t[v].link = to;
    }
    void add_symbol(int c) {
        assert(0 <= c && c < A);
        s.push_back(c);
        while(1) {
            State hlp = go( cur_state, (int)s.size() - 1, (int)s.size() );
            if(hlp.v != -1) { cur_state = hlp; break; }
            int v = get_vertex(cur_state);
            Node add((int)s.size() - 1, +inf, -1, v);
            t.push_back(add);
            t[v].next(c) = (int)t.size() - 1;
            cur_state.v = get_link(v);
            cur_state.len = t[cur_state.v].get_len();
            if(!v) break;
        }
    }
};
\end{minted}

\Section{Suffix Array}

\begin{minted}[linenos,frame=single]{c++}
const int LOG = 21;
struct SuffixArray {
    string s;
    int n;
    vec< int > p;
    vec< int > c[LOG];
    SuffixArray(): n(0) { }
    SuffixArray(string ss): s(ss) {
        s.push_back(0);
        n = (int)s.size();
        vec< int > pn, cn;
        vec< int > cnt;
        p.resize(n);
        for(int i = 0;i < LOG;i++) c[i].resize(n);
        pn.resize(n);
        cn.resize(n);
        cnt.assign(300, 0);
        for(int i = 0;i < n;i++) cnt[s[i]]++;
        for(int i = 1;i < (int)cnt.size();i++) cnt[i] += cnt[i - 1];
        for(int i = n - 1;i >= 0;i--) p[--cnt[s[i]]] = i;
        for(int i = 1;i < n;i++) {
            c[0][p[i]] = c[0][p[i - 1]];
            if(s[p[i]] != s[p[i - 1]]) c[0][p[i]]++;
        }
        for(int lg = 0, k = 1;k < n;k <<= 1, lg++) {
            for(int i = 0;i < n;i++) {
                if((pn[i] = p[i] - k) < 0) pn[i] += n;
            }
            cnt.assign(n, 0);
            for(int i = 0;i < n;i++) cnt[c[lg][pn[i]]]++;
            for(int i = 1;i < (int)cnt.size();i++) cnt[i] += cnt[i - 1];
            for(int i = n - 1;i >= 0;i--) p[--cnt[c[lg][pn[i]]]] = pn[i];
            for(int l1, r1, l2, r2, i = 1;i < n;i++) {
                cn[p[i]] = cn[p[i - 1]];
                l1 = p[i - 1];
                l2 = p[i];
                if((r1 = l1 + k) >= n) r1 -= n;
                if((r2 = l2 + k) >= n) r2 -= n;
                if(c[lg][l1] != c[lg][l2] || c[lg][r1] != c[lg][r2]) cn[p[i]]++;
            }
            c[lg + 1] = cn;
        }
        p.erase(p.begin(), p.begin() + 1);
        n--;
    }
    int get_lcp(int i, int j) {
        int res = 0;
        for(int lg = LOG - 1;lg >= 0;lg--) {
            if(i + (1 << lg) > n || j + (1 << lg) > n) continue;
            if(c[lg][i] == c[lg][j]) {
                i += (1 << lg);
                j += (1 << lg);
                res += (1 << lg);
            }
        }
        return res;
    }
};
\end{minted}

\Section{Suffix automaton}

\begin{minted}[linenos,frame=single]{c++}
struct suf_auto {
    vector<int> base, suf, len;
    vector<vector<int>> g;
    int last, sz;
    suf_auto(): base(26, -1), g(1, base), suf(1, -1), len(1, 0), last(0), sz(1){}
    void add_string(const string &s) {
        for (char c : s) {
            c -= 'a';
            int cur = last;
            last = sz++;
            g.push_back(base);
            suf.emplace_back();
            len.push_back(len[cur] + 1);
            while (cur != -1 && g[cur][c] == -1)
                g[cur][c] = last, cur = suf[cur];
            if (cur == -1) {
                suf[last] = 0;
                continue;
            }
            int nx = g[cur][c];
            if (len[nx] == len[cur] + 1) {
                suf[last] = nx;
                continue;
            }
            int cl = sz++;
            g.push_back(g[nx]);
            suf.push_back(suf[nx]);
            len.push_back(len[cur] + 1);
            suf[last] = suf[nx] = cl;
            while (cur != -1 && g[cur][c] == nx)
                g[cur][c] = cl, cur = suf[cur];
        }
    }
};
\end{minted}

\Section{Kasai}

\begin{minted}[linenos,frame=single]{c++}
vector<int> get_lcp(const string& s, const vector<int>& suf){
    int n = (int)suf.size();
    vector<int> back(n);
    for(int i = 0; i < n; i++) back[suf[i]] = i;
    vector<int> lcp(n - 1);
    for(int i = 0, k = 0; i < n; i++){
        int x = back[i]; k = max(0, k - 1);
        if(x == n - 1){k = 0; continue;}
        while(s[suf[x] + k] == s[suf[x + 1] + k]) k++;
        lcp[x] = k;
    }
    return lcp;
}
\end{minted}

\Section{Z-function}

\begin{minted}[linenos,frame=single]{c++}
vector<int> get_z(const string& s){
    int n = (int)s.length();
    vector<int> z(n);
    for(int i = 1, l = 0, r = 0; i < n; i++){
        if(i < r) z[i] = min(r - i, z[i - l]);
        while(i + z[i] < n && s[z[i]] == s[i + z[i]]) z[i]++;
        if(i + z[i] > r) l = i, r = i + z[i];
    }
    return z;
}
\end{minted}

\Section{prefix-function}

\begin{minted}[linenos,frame=single]{c++}
vector<int> get_pi(const string& s){
    int n = (int)s.length();
    vector<int> pr(n);
    for(int i = 1; i < n; i++){
        int k = pr[i - 1];
        while(k && s[k] != s[i]) k = pr[k - 1];
        if(s[k] == s[i]) k++;
        pr[i] = k;
    }
    return pr;
}
\end{minted}

\Section{Aho}

\begin{minted}[linenos,frame=single]{c++}
const int A = 300; // alphabet size
struct Aho {
    struct Node {
        int nxt[A], go[A];
        int par, pch, link;
        int good;
        Node(): par(-1), pch(-1), link(-1), good(-1) {
            fill(nxt, nxt + A, -1); fill(go, go + A, -1); }
    };
    vec< Node > a;
    Aho() { a.push_back(Node()); }
    void add_string(const string &s) {
        int v = 0;
        for(char c : s) {
            if(a[v].nxt[c] == -1) {
                a[v].nxt[c] = (int)a.size();
                a.push_back(Node());
                a.back().par = v;
                a.back().pch = c;
            }
            v = a[v].nxt[c];
        }
        a[v].good = 1;
    }
    int go(int v, int c) {
        if(a[v].go[c] == -1) {
            if(a[v].nxt[c] != -1) {
                a[v].go[c] = a[v].nxt[c];
            }else {
                a[v].go[c] = v ? go(get_link(v), c) : 0;
            }
        }
        return a[v].go[c];
    }
    int get_link(int v) {
        if(a[v].link == -1) {
            if(!v || !a[v].par) a[v].link = 0;
            else a[v].link = go(get_link(a[v].par), a[v].pch);
        }
        return a[v].link;
    }
    bool is_good(int v) {
        if(!v) return false;
        if(a[v].good == -1) {
            a[v].good = is_good(get_link(v));
        }
        return a[v].good;
    }
    bool is_there_substring(const string &s) {
        int v = 0;
        for(char c : s) {
            v = go(v, c);
            if(is_good(v)) {
                return true;
            }
        }
        return false;
    }
};
\end{minted}

\Section{Hungarian}

\begin{minted}[linenos,frame=single]{c++}
vector<int> Hungarian(const vector< vector<int> >& a){ // ALARM: INT everywhere
    int n = (int)a.size();
    vector<int> row(n), col(n), pair(n, -1), back(n, -1), prev(n, -1);
    auto get = [&](int i, int j){ return a[i][j] + row[i] + col[j];};
    for(int v = 0; v < n; v++){
        vector<int> min_v(n, v), A_plus(n), B_plus(n);
        A_plus[v] = 1; int jb;
        while(true){
            int pos_i = -1, pos_j = -1;
            for(int j = 0; j < n; j++){
                if(!B_plus[j] && (pos_i == -1 || 
                    get(min_v[j], j) < get(pos_i, pos_j))) {
                    pos_i = min_v[j], pos_j = j;
                }
            }
            int weight = get(pos_i, pos_j);
            for(int i = 0; i < n; i++) if(!A_plus[i]) row[i] += weight;
            for(int j = 0; j < n; j++) if(!B_plus[j]) col[j] -= weight;
            B_plus[pos_j] = 1, prev[pos_j] = pos_i;
            int x = back[pos_j];
            if(x == -1) { jb = pos_j; break;}
            A_plus[x] = 1;
            for(int j = 0; j < n; j++)
                if(get(x, j) < get(min_v[j], j))
                    min_v[j] = x;
        }
        while(jb != -1){
            back[jb] = prev[jb];
            swap(pair[prev[jb]], jb);
        }
    }
    return pair;
}
\end{minted}

\Section{Hopkroft-Karp}

\begin{minted}[linenos,frame=single]{c++}
struct HopcroftKarp {
    int n, m;
    vec< vec< int > > g;
    vec< int > pl, pr, dist;
    HopcroftKarp(): n(0), m(0) { }
    HopcroftKarp(int _n, int _m): n(_n), m(_m) { g.resize(n); }
    void add_edge(int u, int v) { g[u].push_back(v); }
    bool bfs() {
        dist.assign(n + 1, inf);
        queue< int > q;
        for(int u = 0;u < n;u++) {
            if(pl[u] < m) continue;
            dist[u] = 0;
            q.push(u);
        }
        while(!q.empty()) {
            int u = q.front();
            q.pop();
            if(dist[u] >= dist[n]) continue;
            for(int v : g[u]) {
                if(dist[ pr[v] ] > dist[u] + 1) {
                    dist[ pr[v] ] = dist[u] + 1;
                    q.push(pr[v]);
                }
            }
        }
        return dist[n] < inf;
    }
    bool dfs(int v) {
        if(v == n) return 1;
        for(int to : g[v]) {
            if(dist[ pr[to] ] != dist[v] + 1) continue;
            if(!dfs(pr[to])) continue;
            pl[v] = to;
            pr[to] = v;
            return 1;
        }
        return 0;
    }
    int find_max_matching() {
        pl.resize(n, m);
        pr.resize(m, n);
        int result = 0;
        while(bfs()) {
            for(int u = 0;u < n;u++) {
                if(pl[u] < m) continue;
                result += dfs(u);
            }
        }
        return result;
    }
};
\end{minted}

\Section{CHT}

\begin{minted}[linenos,frame=single]{c++}
struct Line {
    ll k, b;
    int type;
    ld x;
    Line(): k(0), b(0), type(0), x(0) { }
    Line(ll _k, ll _b, ld _x = 1e18, int _type = 0): 
        k(_k), b(_b), x(_x), type(_type) { }
    bool operator<(const Line& other) const {
        if(type + other.type > 0) { return x < other.x;
        }else { return k < other.k; }
    }
    ld intersect(const Line& other) const {
        return ld(b - other.b) / ld(other.k - k);
    }
    ll get_func(ll x0) const {
        return k * x0 + b;
    }
 };
struct CHT {
    set< Line > qs;
    set< Line > :: iterator fnd, help;
    bool hasr(const set< Line > :: iterator& it) {
        return it != qs.end() && next(it) != qs.end(); }
    bool hasl(const set< Line > :: iterator& it) {
        return it != qs.begin(); }
    bool check(const set< Line > :: iterator& it) {
        if(!hasr(it)) return true;
        if(!hasl(it)) return true;
        return it->intersect(*prev(it)) < it->intersect(*next(it)); }
    void update_intersect(const set< Line > :: iterator& it) {
        if(it == qs.end()) return;
        if(!hasr(it)) return;
        Line tmp = *it;
        tmp.x = tmp.intersect(*next(it));
        qs.insert(qs.erase(it), tmp);
    }
    void add_line(Line L) {
        if(qs.empty()) { qs.insert(L); return; }
        {   fnd = qs.lower_bound(L);
            if(fnd != qs.end() && fnd->k == L.k) {
                if(fnd->b >= L.b) return;
                else qs.erase(fnd);
            } 
        }
        fnd = qs.insert(L).first;
        if(!check(fnd)) { qs.erase(fnd); return; }
        while(hasr(fnd) && !check(help = next(fnd))) { qs.erase(help); }
        while(hasl(fnd) && !check(help = prev(fnd))) { qs.erase(help); }
        if(hasl(fnd)) { update_intersect(prev(fnd)); }
        update_intersect(fnd);
    }
    ll get_max(ld x0) {
        if(qs.empty()) return -inf64;
        fnd = qs.lower_bound(Line(0, 0, x0, 1));
        if(fnd == qs.end()) fnd--;
        ll res = -inf64; int i = 0;
        while(i < 2 && fnd != qs.end()) {
            res = max(res, fnd->get_func(x0));
            fnd++;
            i++;
        }
        while(i-- > 0) fnd--;
        while(i < 2) {
            res = max(res, fnd->get_func(x0));
            if(hasl(fnd)) {
                fnd--; i++;
            }else {
                break;
            }
        }
        return res;
    }
};
\end{minted}

\Section{FFT with prime mod}

\begin{minted}[linenos,frame=single]{c++}
const int mod = 998244353;
const int root = 31;
const int LOG = 23;
const int N = 1e5 + 5;
vec< int > G[LOG + 1];
vec< int > rev[LOG + 1];
inline void _add(int &x, int y);
inline int _sum(int a, int b);
inline int _sub(int a, int b);
inline int _mul(int a, int b);
inline int _binpow(int x, int p);
inline int _rev(int x);
void precalc() {
    for(int start = root, lvl = LOG;lvl >= 0;lvl--, start = _mul(start, start)) {
        int tot = 1 << lvl;
        G[lvl].resize(tot);
        for(int cur = 1, i = 0;i < tot;i++, cur = _mul(cur, start)) {
            G[lvl][i] = cur;
        }
    }
    for(int lvl = 1;lvl <= LOG;lvl++) {
        int tot = 1 << lvl;
        rev[lvl].resize(tot);
        for(int i = 1;i < tot;i++) {
            rev[lvl][i] = ((i & 1) << (lvl - 1)) | (rev[lvl][i >> 1] >> 1);
        }
    }
}
void fft(vec< int > &a, int sz, bool invert) {
    int n = 1 << sz;
    for(int j, i = 0;i < n;i++) {
        if((j = rev[sz][i]) < i) {
            swap(a[i], a[j]);
        }
    }
    for(int f1, f2, lvl = 0, len = 1;len < n;len <<= 1, lvl++) {
        for(int i = 0;i < n;i += (len << 1)) {
            for(int j = 0;j < len;j++) {
                f1 = a[i + j];
                f2 = _mul(a[i + j + len], G[lvl + 1][j]);
                a[i + j] = _sum(f1, f2);
                a[i + j + len] = _sub(f1, f2);
            }
        }
    }
    if(invert) {
        reverse(a.begin() + 1, a.end());
        int rn = _rev(n);
        for(int i = 0;i < n;i++) {
            a[i] = _mul(a[i], rn);
        }
    }
}
vec< int > multiply(const vec< int > &a, const vec< int > &b) {
    vec< int > fa(ALL(a));
    vec< int > fb(ALL(b));
    int n = (int)a.size();
    int m = (int)b.size();
    int maxnm = max(n, m), sz = 0;
    while((1 << sz) < maxnm) sz++; sz++;
    fa.resize(1 << sz);
    fb.resize(1 << sz);
    fft(fa, sz, false);
    fft(fb, sz, false);
    int SZ = 1 << sz;
    for(int i = 0;i < SZ;i++) { fa[i] = _mul(fa[i], fb[i]); }
    fft(fa, sz, true);
    while((int)fa.size() > 1 && !fa.back()) fa.pop_back();
    return fa;
}
\end{minted}

\Section{FFT with ld}

\begin{minted}[linenos,frame=single]{c++}
struct Complex {
    ld rl = 0, im = 0;
    Complex() = default;
    Complex(ld x, ld y = 0): rl(x), im(y) { }
    Complex & operator = (const Complex &o) {
        if(this != &o) {
            rl = o.rl;
            im = o.im;
        }
        return *this;
    }
    Complex operator + (const Complex &o) const { return {rl + o.rl, im + o.im}; }
    Complex operator - (const Complex &o) const { return {rl - o.rl, im - o.im}; }
    Complex operator * (const Complex &o) const { 
        return {rl * o.rl - im * o.im, rl * o.im + im * o.rl}; }
    Complex & operator *= (const Complex &o) {
        (*this) = (*this) * o;
        return *this;
    }
    Complex operator / (const Complex &o) const {
        ld md = o.rl * o.rl + o.im * o.im;
        return {(rl * o.rl + im * o.im) / md, (im * o.rl - rl * o.im) / md};
    }
    Complex & operator /= (int k) {
        rl /= k;
        im /= k;
        return *this;
    }
    ld real() const { return rl; }
    ld imag() const { return im; }
};
typedef Complex base;
const int LOG = 20;
const int N = 1 << LOG;
int rev[N];
vec< base > PW[LOG + 1];
void precalc() {
    for(int i = 1;i < N;i++) { 
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (LOG - 1)); }
    for(int lvl = 0;lvl <= LOG;lvl++) {
        int sz = 1 << lvl;
        ld alpha = 2 * pi / sz;
        base root(cos(alpha), sin(alpha));
        base cur = 1;
        PW[lvl].resize(sz);
        for(int j = 0;j < sz;j++) {
            PW[lvl][j] = cur;
            cur *= root;
        }
    }
}
void fft(base *a, bool invert = 0) {
    for(int j, i = 0;i < N;i++) {
        if((j = rev[i]) > i) swap(a[i], a[j]);
    }
    base u, v;
    for(int lvl = 0;lvl < LOG;lvl++) {
        int len = 1 << lvl;
        for(int i = 0;i < N;i += (len << 1)) {
            for(int j = 0;j < len;j++) {
                u = a[i + j];
                v = a[i + j + len] * 
                    (invert?PW[lvl+1][j?(len << 1)-j:0]:PW[lvl+1][j]);
                a[i + j] = u + v;
                a[i + j + len] = u - v;
            }
        }
    }
    if(invert) {
        for(int i = 0;i < N;i++) {
            a[i] /= N;
        }
    }
}
\end{minted}

\Section{Convex-Hull}
\begin{minted}[linenos,frame=single]{c++}
struct Point {
    ll x, y;
    Point(){}
    Point(ll x, ll y): x(x), y(y) {}
    bool operator <(const Point &a) const { 
        return make_pair(x, y) < make_pair(a.x, a.y); }
    Point operator +(const Point &a) const { return {x + a.x, y + a.y}; }
    Point operator -(const Point &a) const { return {x - a.x, y - a.y}; }
    ll cross_product(const Point &a) const { return x * a.y - y * a.x; }
    ll len2() const { return x * x + y * y; }
};
vector<Point> convex_hull(vector<Point> v) {
    Point O = v[0];
    int pos = 0;
    for (int i = 0; i < v.size(); i++) {
        if (v[i] < O)
            tie(pos, O) = {i, v[i]};
    }
    swap(v[0], v[pos]);
    v = {v.begin() + 1, v.end()};
    sort(v.begin(), v.end(), [&O](const Point &a, const Point &b){
        ll prod = (a - O).cross_product(b - O);
        if (prod)
            return prod > 0;
        return (a - O).len2() < (b - O).len2();
    });
    vector<Point> ret{O};
    for (Point &p : v) {
        while (ret.size() > 1) {
            Point fr = p - ret[ret.size() - 2], 
                sc = ret[ret.size() - 1] - ret[ret.size() - 2];
            ll prod = sc.cross_product(fr);
            if (prod > 0)
                break;
            ret.pop_back();
        }
        ret.push_back(p);
    }
    return ret;
};
\end{minted}

\Section{Palindrome-Tree}
\begin{minted}[linenos,frame=single]{c++}
struct pal_tree {
    int sz;
    vector<unordered_map<int,int>> g;
    vector<int> len, suf, cn, base;
    vector<int> fin;
    int cur, v;
    pal_tree(): g(2),sz(2),len({-1, 0}),cn({0, 0}),suf({0, 0}),cur(0),v(1){}
    void add_string (const string &s) {
        for (int i = 0; i < s.length(); i++) {
            char c = s[i] - 'a';
            while (i - len[v] - 1 < 0 || s[i - len[v] - 1] - 'a' != c)
                v = suf[v];
            if (!g[v].count(c)) {
                g.emplace_back();
                int t = len[v];
                len.push_back(t + 2);
                int u = v;
                do {
                    u = suf[u];
                } while (u && s[i - len[u] - 1] - 'a' != c);
                suf.push_back(!g[u].count(c) ? 1 : g[u][c]);
                t = cn[suf.back()];
                cn.push_back(t + 1);
                g[v][c] = sz++;
                cur++;
            }
            v = g[v][c];
            fin.push_back(cn[v]);
        }
        return;
    }
};
\end{minted}

\Section{STL TREE, HASH\_MAP}

\begin{minted}[linenos,frame=single]{c++}
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
using namespace std;
typedef
    tree<
        pair< int, int >,
        null_type,
        less< pair< int, int > >,
        rb_tree_tag,
        tree_order_statistics_node_update
    > stat_set;
// ...
ordered_set X;
    X.insert(1);
    X.insert(2);
    X.insert(4);
    X.insert(8);
    X.insert(16);
    cout<<*X.find_by_order(1)<<endl; // 2
    cout<<*X.find_by_order(2)<<endl; // 4
    cout<<*X.find_by_order(4)<<endl; // 16
    cout<<(end(X)==X.find_by_order(6))<<endl; // true
    cout<<X.order_of_key(-5)<<endl;  // 0
    cout<<X.order_of_key(1)<<endl;   // 0
    cout<<X.order_of_key(3)<<endl;   // 2
    cout<<X.order_of_key(4)<<endl;   // 2
    cout<<X.order_of_key(400)<<endl; // 5
// ...
// pbds
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/detail/standard_policies.hpp>
using namespace __gnu_pbds;
gp_hash_table<int, int> table; // the usage is the same as the unordered_map
\end{minted}

\Section{Dinic}

\begin{minted}[linenos,frame=single]{c++}
struct Dinic {
    struct Edge { int fr, to, cp, id, fl; };
    int n, S, T;
    vec< Edge > es;
    vec< vec< int > > g;
    vec< int > dist, res, ptr;
    Dinic(int _n, int _S, int _T): 
        n(_n), S(_S), T(_T) { g.resize(n); }
    void add_edge(int fr, int to, int cp, int id) {
        g[fr].push_back((int)es.size());
        es.push_back({fr, to, cp, id, 0});
        g[to].push_back((int)es.size());
        es.push_back({to, fr, 0, -1, 0});
    }
    bool bfs(int K) {
        dist.assign(n, inf);
        dist[S] = 0;
        queue< int > q;
        q.push(S);
        while(!q.empty()) {
            int v = q.front();
            q.pop();
            for(int ps : g[v]) {
                Edge &e = es[ps];
                if(e.fl + K > e.cp) continue;
                if(dist[e.to] > dist[e.fr] + 1) {
                    dist[e.to] = dist[e.fr] + 1;
                    q.push(e.to);
                }
            }
        }
        return dist[T] < inf;
    }
    int dfs(int v, int _push = INT_MAX) {
        if(v == T || !_push) return _push;
        for(int &iter = ptr[v];iter < (int)g[v].size();iter++) {
            int ps = g[v][ ptr[v] ];
            Edge &e = es[ps];
            if(dist[e.to] != dist[e.fr] + 1) continue;
            int tmp = dfs(e.to, min(_push, e.cp - e.fl));
            if(tmp) {
                e.fl += tmp;
                es[ps ^ 1].fl -= tmp;
                return tmp;
            }
        }
        return 0;
    }
    ll find_max_flow() {
        ptr.resize(n);
        ll max_flow = 0, add_flow;
        for(int K = 1 << 30;K > 0;K >>= 1) {
            while(bfs(K)) {
                ptr.assign(n, 0);
                while((add_flow = dfs(S))) {
                    max_flow += add_flow;
                }
            }
        }
        return max_flow;
    }
    void assign_result() {
        res.resize(es.size());
        for(Edge e : es) if(e.id != -1) res[e.id] = e.fl; }
    int get_flow(int id) { return res[id]; }
    bool go(int v, vec< int > &F, vec< int > &path) {
        if(v == T) return 1;
        for(int ps : g[v]) {
            if(F[ps] <= 0) continue;
            if(go(es[ps].to, F, path)) {
                path.push_back(ps);
                return 1;
            }
        }
        return 0;
    }
    vec< pair< int, vec< int > > > decomposition() {
        find_max_flow();
        vec< int > F((int)es.size()), path, add;
        vec< pair< int, vec< int > > > dcmp;
        for(int i = 0;i < (int)es.size();i++) F[i] = es[i].fl;
        while(go(S, F, path)) {
            int mn = INT_MAX;
            for(int ps : path) mn = min(mn, F[ps]);
            for(int ps : path) F[ps] -= mn;
            for(int ps : path) add.push_back(es[ps].id);
            reverse(ALL(add));
            dcmp.push_back({mn, add});
            add.clear();
            path.clear();
        }
        return dcmp;
    }
};
\end{minted}

\Section{MCMF}

\begin{minted}[linenos,frame=single]{c++}
struct MCMF {
    struct Edge { int fr, to, cp, fl, cs, id; };
    int n, S, T;
    vec< Edge > es;
    vec< vec< int > > g;
    vec< ll > dist, phi;
    vec< int > from;
    MCMF(int _n, int _S, int _T): n(_n), S(_S), T(_T)
    { g.resize(n); }
    void add_edge(int fr, int to, int cp, int cs, int id) {
        g[fr].push_back((int)es.size());
        es.push_back({fr, to, cp, 0, cs, id});
        g[to].push_back((int)es.size());
        es.push_back({to, fr, 0, 0, -cs, -1});
    }
    void init_phi() {
        dist.assign(n, LLONG_MAX);
        dist[S] = 0;
        for(int any, iter = 0;iter < n - 1;iter++) { // Ford Bellman
            any = 0;
            for(Edge e : es) {
                if(e.fl == e.cp) continue;
                if(dist[e.to] - dist[e.fr] > e.cs) {
                    dist[e.to] = dist[e.fr] + e.cs;
                    any = 1;
                }
            }
            if(!any) break;
        }
        phi = dist;
    }
    bool Dijkstra() {
        dist.assign(n, LLONG_MAX);
        from.assign(n, -1);
        dist[S] = 0;
        priority_queue< pair< ll, int >, vec< pair< ll, int > >, 
            greater< pair< ll, int > > > pq;
        pq.push({dist[S], S});
        while(!pq.empty()) {
            int v;
            ll di;
            tie(di, v) = pq.top();
            pq.pop();
            if(di != dist[v]) continue;
            for(int ps : g[v]) {
                Edge &e = es[ps];
                if(e.fl == e.cp) continue;
                if(dist[e.to] - dist[e.fr] > e.cs + phi[e.fr] - phi[e.to]) {
                    dist[e.to] = dist[e.fr] + e.cs + phi[e.fr] - phi[e.to];
                    from[e.to] = ps;
                    pq.push({dist[e.to], e.to});
                }
            }
        }
        for(int v = 0;v < n;v++) {
            phi[v] += dist[v];
        }
        return dist[T] < LLONG_MAX;
    }
    pll find_mcmf() {
        init_phi();
        ll flow = 0, cost = 0;
        while(Dijkstra()) {
            int mn = INT_MAX;
            for(int v = T;v != S;v = es[ from[v] ].fr) {
                mn = min(mn, es[from[v]].cp - es[from[v]].fl);
            }
            flow += mn;
            for(int v = T;v != S;v = es[ from[v] ].fr) {
                es[ from[v] ].fl += mn;
                es[ from[v] ^ 1 ].fl -= mn;
            }
        }
        for(Edge &e : es) {
            if(e.fl >= 0)
                cost += 1ll * e.fl * e.cs;
        }
        return make_pair(flow, cost);
    }
    bool go(int v, vec< int > &F, vec< int > &path, vec< int > &used) {
        if(used[v]) return 0;
        used[v] = 1;
        if(v == T) return 1;
        for(int ps : g[v]) {
            if(F[ps] <= 0) continue;
            if(go(es[ps].to, F, path, used)) {
                path.push_back(ps);
                return 1;
            }
        }
        return 0;
    }
    vec< pair< int, vec< int > > > decomposition(ll &_flow, ll &_cost) {
        tie(_flow, _cost) = find_mcmf();
        vec< int > F((int)es.size()), path, add, used(n);
        vec< pair< int, vec< int > > > dcmp;
        for(int i = 0;i < (int)es.size();i++) F[i] = es[i].fl;
        while(go(S, F, path, used)) {
            used.assign(n, 0);
            int mn = INT_MAX;
            for(int ps : path) mn = min(mn, F[ps]);
            for(int ps : path) F[ps] -= mn;
            for(int ps : path) add.push_back(es[ps].id);
            reverse(ALL(add));
            dcmp.push_back({mn, add});
            add.clear();
            path.clear();
        }
        return dcmp;
    }
};
\end{minted}

\Section{Pollard}

\begin{minted}[linenos,frame=single]{c++}
namespace FACTORIZE {
    const ll MAXX = 1000;
    const int FERMA_ITER = 30;
    // const int POLLARD_PO_ITER = 10000;
    int POLLARD_PO_ITER;
    inline ll sqr(ll n) { return n * n; }
    ll check_small(ll n) {
        for(ll x = 1;sqr(x) <= n && x <= MAXX;x++) {
            if(x > 1 && n % x == 0) {
                return x;
            }else if(sqr(x + 1) > n) {
                return -1;
            }
        }
        return -1;
    }
    ll check_square(ll n) {
        ll bl = 0;
        ll br = 3e9+1;
        ll bm;
        while(br - bl > 1) {
            bm = (bl + br) / 2;
            if(sqr(bm) <= n) {
                bl = bm;
            }else {
                br = bm;
            }
        }
        if(sqr(bl) == n && bl > 1) {
            return bl;
        }else {
            return -1;
        }
    }
    inline ll _mul(ll a, ll b, ll m) {
        static __int128 xa = 1;
        static __int128 xb = 1;
        static __int128 xm = 1;
        xa = a;
        xb = b;
        xm = m;
        return ll(xa * xb % xm);
    }
    /*
    ll _mul(ll x, ll y, ll mod) {
        ll q = ld(x) * ld(y) / ld(mod);
        ll r = x * y - q * mod;
        return (r % mod + mod) % mod;
    }*/
    inline ll _binpow(ll x, ll p, ll m) {
        static ll res = 1;
        static ll tmp = 1;
        res = 1;
        tmp = x;
        while(p > 0) {
            if(p & 1ll) {
                res = _mul(res, tmp, m);
            }
            tmp = _mul(tmp, tmp, m);
            p >>= 1;
        }
        return res;
    }
    mt19937_64 next_rand(179);
    ll gcd(ll x, ll y) { return !x ? y : gcd(y % x, x); }
    bool is_prime(ll n) {
        if(n <= 1) return false;
        if(n == 2) return true;
        ll a, g;
        for(int iter = 0;iter < FERMA_ITER;iter++) {
            a = next_rand() % (n - 2);
            if(a < 0) a += n - 2;
            a += 2;
            assert(1 < a && a < n);
            g = gcd(a, n);
            if(g != 1) { return false; }
            if(_binpow(a, n - 1, n) != 1) { return false; }
        }
        return true;
    }
    inline ll _func(ll x, ll n) {
        static ll result = 1;
        result = _mul(x, x, n);
        return result + 1 < n ? result + 1 : 0;
    }
    ll pollard_po(ll n) {
        POLLARD_PO_ITER = 5 + 3 * pow(n, 0.25);
        ll a, b, x, g;
        while(1) {
            a = next_rand() % n;
            if(a < 0) a += n;
            b = next_rand() % n;
            if(b < 0) b += n;
            for(int iter = 0;iter < POLLARD_PO_ITER;iter++) {
                x = a >= b ? a - b : b - a;
                g = gcd(x, n);
                if(1 < g && g < n) {
                    return g;
                }
                a = _func(a, n);
                b = _func(_func(b, n), n);
            }
        }
    }
    ll get_div(ll n) {
        ll res;
        res = check_small(n);
        if(res != -1) { return res; }
        res = check_square(n);
        if(res != -1) { return res; }
        if(is_prime(n)) { return n; }
        return pollard_po(n);
    }
}
\end{minted}

\end{document}
